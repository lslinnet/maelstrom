#!/usr/bin/python
"""
Maelstrom - visualizing email contacts
Copyright(c) 2008-2009 Stefan Marsiske <my name at gmail.com>

extracts a directed graph from the database.
  edges are the messages,
  nodes are the persons
  edges have a type to/cc and a weight (number of mails)
"""

import sys
import os
import getopt
import platform
import ConfigParser
if(platform.machine()=='i686'):
   import psyco

from lib.objects import Role
from lib.utils import Obj, UnicodeWriter, counter

# config object holding our context
CFG = ConfigParser.ConfigParser()

# ID generators for nodes and eges
NodeIdGenerator = iter(counter(0))
EdgeIdGenerator = iter(counter(0))

def usage():
   """Prints out the --help"""
   print "usage: %s" % (sys.argv[0])
   print "\t-h                                  This Help"
   print "\t-s|--stats                          Display stats"
#   print "\t-f |--format== [dot,log,graphxml]   Output format."
   print "\t-f |--format== [dot,log,csv]        Output format."

class Node(Obj):
   """
   Simple graph node, that keeps track of the edges by
    - direction,
    - time and
    - type/timestamp
   """
   def __init__(self, name):
      self.__dict__['id'] = "n"+str(NodeIdGenerator.next())
      self.__dict__['name'] = name
      self.__dict__['srcTypeStamps'] = []
      self.__dict__['dstTypeStamps'] = []

   def __str__(self):
      return "%s\t(Wo:%d, Wi:%d)\n" % (self.name,
                                       len(self.srcTypeStamps),
                                       len(self.dstTypeStamps))

   def incsrcweight(self, mode, date):
      """
      add an incomming edge to the node
      """
      self.__dict__['srcTypeStamps'].append((date, mode))

   def incdstweight(self, mode, date):
      """
      add an outgoing edge to the node
      """
      self.__dict__['dstTypeStamps'].append((date, mode))

class Edge(Obj):
   """
   Simple graph edge, that keeps track of the nodes by
    - type/timestamp
   """
   def __init__(self, sender, receiver):
      self.__dict__['id'] = "e"+str(EdgeIdGenerator.next())
      self.__dict__['sender'] = sender
      self.__dict__['to'] = receiver
      self.__dict__['typestamps'] = []

   def __str__(self):
      return "%s -> %s W:%d\n" % (self.sender,
                                  self.to,
                                  len(self.typestamps))
   def incweight(self, mode, date):
      """
      adjust the weight of the edge
      """
      self.__dict__['typestamps'].append((date, mode))

class Graph(Obj):
   """
   graph object: implements
    - building
    - exporting as dot,log,csv
    - gathering statistics
   """
   def __init__(self):
      self.__dict__['nodes'] = {}
      self.__dict__['edges'] = {}

   def __str__(self):
      return "Nodes: %s\nEdges: %s\n" % (self.nodes, self.edges)

   def addedge(self, sender, mode, to, date):
      """adds an edge to the graph, creating non-existing nodes as
      necessary, adjusting weights at each object properly."""
      src = edge = dst = None
      # create nodes if not yet seen
      if(not sender in self.nodes.keys()):
         src = Node(sender)
         self.nodes[sender] = src
      else:
         src = self.nodes[sender]

      if(not to in self.nodes.keys()):
         dst = Node(to)
         self.nodes[to] = dst
      else:
         dst = self.nodes[to]

      # create edge if a new one is found
      if(not (sender, to) in self.edges.keys()):
         edge = Edge(sender, to)
         self.edges[(sender, to)] = edge
      else:
         edge = self.edges[(sender, to)]

      # adjust weight on edge
      edge.incweight(mode, date)

      # adjust weight on nodes
      src.incsrcweight(mode, date)
      dst.incdstweight(mode, date)

   def stats(self):
      nodes = self.__dict__['nodes'].values()
      nodes.sort(lambda x, y: cmp(len(y.srcTypeStamps)+len(y.dstTypeStamps),
                                 len(x.srcTypeStamps)+len(x.dstTypeStamps)))
      print "Top Overall\n", nodes[:10]

      # print out top senders
      nodes = self.__dict__['nodes'].values()
      nodes.sort(lambda x, y: cmp(len(y.srcTypeStamps),
                                 len(x.srcTypeStamps)))
      print "Top Wo\n", nodes[:10]

      # print out top recipients
      nodes = self.__dict__['nodes'].values()
      nodes.sort(lambda x, y: cmp(len(y.dstTypeStamps),
                                 len(x.dstTypeStamps)))
      print "Top Wi\n", nodes[:10]

      # print out top edges
      edges = self.__dict__['edges'].values()
      edges.sort(lambda x, y: cmp(len(y.typestamps), len(x.typestamps)))
      print "Top Overall edges\n", edges[:10]

      if(CFG.get('maelstrom','egg')):
         edges = filter(lambda x: (
            x.sender!=CFG.get('maelstrom','egger')), edges)
         edges.sort(lambda x, y: cmp(len(y.typestamps), len(x.typestamps)))
         print "Top Overall eggs\n", edges[:10]

   def dot(self):
      """
      outputs the graph in graphviz dot language
      """
      result = "digraph G {\noverlap = false;\nsplines=true;\n"
      result += reduce(lambda y, x: y+'%s [ label="%s"];\n' %
                     (self.nodes[x.name].id, x.name),
                     self.nodes.values(),"")
      result += reduce(lambda y, x: y+'"%s" -> "%s" [ weight="%d" ];\n' %
                     (self.nodes[x.sender].id,
                      self.nodes[x.to].id,
                      len(x.typestamps)),
                     self.edges.values(),"")
      result += "}"
      return result

class PersonMap:
   """
   maps names or email addresses to other names specified in a configure
   """
   def __init__(self, fname):
      self.__dict__['personmap'] = {}
      if(os.path.exists(fname)):
         fp = open(fname,'r')
         while(fp):
            line = fp.readline()
            if not line:
               break
            (email, name) = line.split(" ", 1)
            self.__dict__['personmap'][email] = name.strip()
         fp.close()

   def __getitem__(self, name):
      if(name and self.__dict__['personmap'].has_key(name)):
         return self.__dict__['personmap'][name]
      else:
         return name

def process():
   graph = Graph()
   personmap = PersonMap(
      os.path.abspath(CFG.get('maelstrom','personmapfile')))
   csvcoder = None
   if(CFG.get('maelstrom','format') == "csv"):
      csvcoder = UnicodeWriter(sys.stdout)

   q = Role.select()
   for edge in q:
      try:
         sender = personmap[edge.msg.sender.getname()]
      except AttributeError:
         continue
      try:
         receiver = personmap[edge.email.getname()]
      except AttributeError:
         continue
      # add edge to graph
      graph.addedge(sender,
                    edge.header.name,
                    receiver,
                    edge.msg.delivered)

      # print out edge in log/csv format if necessary
      if(CFG.get('maelstrom','format') == "log"):
         print edge.msg.delivered, sender, edge.header.name, receiver
      elif(CFG.get('maelstrom','format') == "csv"):
         csvcoder.writerow(map(lambda x: str(x),
                               (edge.msg.delivered,
                                sender,
                                edge.header.name,
                                receiver)))
   #print graph
   if(CFG.get('maelstrom','format') == "dot"):
      print graph.dot()
   if(CFG.get('maelstrom','stats')):
      print graph.stats()

def init():
   """
   initializes the configuration from the config files, then sets the
   command line parameters and finally passes control to the main
   processing function
   """
   CFG.read(['../maelstrom.cfg', os.path.expanduser('~/.maelstrom.cfg')])
   try:
      opts, args = getopt.gnu_getopt(
         sys.argv[1:], "hesf:d:",
         ["help", "egg", "stats", "format=", "database="])
   except getopt.GetoptError:
      usage()
      sys.exit(2)
   for o, a in opts:
      if o in ("-h", "--help"):
         usage()
         sys.exit()
      elif o in ("-d", "--database"):
         if(a and os.path.isfile(a)):
            CFG.set('maelstrom', 'database', os.path.abspath(a))
      elif o in ("-e", "--egg"):
         CFG.set('maelstrom', 'egg', False)
      elif o in ("-s", "--stats"):
         CFG.set('maelstrom', 'stats', True)
      elif o in ("-f", "--format"):
         if(a and a in ("dot", "log", "graphxml", "csv")):
            CFG.set('maelstrom', 'format', a)
         else:
            usage()
            sys.exit()
   # call the main routine for processing the data
   process()

if __name__ == '__main__':
   if(platform.machine()=='i686'):
      psyco.full()
   sys.exit(init())
