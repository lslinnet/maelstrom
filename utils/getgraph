#!/usr/bin/python

# Maelstrom - visualizing email contacts
# Copyright(c) 2008-2009 Stefan Marsiske <my name at gmail.com>

# extracts a directed graph from the database.
#   the edges are the messages,
#   the vertexes are the persons
#   the edges have a type to/cc and a weight (number of mails)

import sys, os, psyco, datetime, getopt, bisect, ConfigParser
from sqlobject import *
from lib.objects import *
from lib.utils import decode_header

CONFIG={'database': os.path.abspath('db/messages.db'),
        'format': "graphviz"}
#config = ConfigParser.ConfigParser()
#config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')])

PERSONMAPFILE='db/persons.map'
personmap={}

class Node:
    def __init__(self,name,receivers=[]):
        self.__dict__['name']=name
        self.__dict__['receivers']=receivers
        self.__dict__['inccs']=0
        self.__dict__['ccs']=0
        self.__dict__['intos']=0
        self.__dict__['tos']=0

    def __getattr__(self, name):
        if(self.__dict__.has_key(name)):
            return self.__dict__[name]
        else:
            raise AttributeError, name

    def __setattr__(self, name, value):
        if(self.__dict__.has_key(name)):
            self.__dict__[name] = value
        else:
            raise AttributeError, name

    def __str__(self):
        #return map(self.__dict__.keys(), lambda x: str(self.__dict__[x]))
        return "%s\t(it:%d, ic:%d, ot:%d, oc:%d)" % (self.name,
                                           self.intos,
                                           self.inccs,
                                           self.tos,
                                           self.ccs)
    def __repr__(self):
        return self.__str__()

class Vertex:
    def __init__(self,sender,to):
        self.__dict__['sender']=sender
        self.__dict__['to']=to
        self.__dict__['typestamps']={}

    def __getattr__(self, name):
        if(self.__dict__.has_key(name)):
            return self.__dict__[name]
        else:
            raise AttributeError, name

    def __setattr__(self, name, value):
        if(self.__dict__.has_key(name)):
            self.__dict__[name] = value
        else:
            raise AttributeError, name

    def __str__(self):
        #return map(self.__dict__.keys(), lambda x: str(self.__dict__[x]))
        return "%s %s %s %s" % (self.date,
                                self.sender,
                                self.typestamps)
    def __repr__(self):
        return self.__str__()

    def incWeight(self,type,date):
        if not self.__dict__['typestamps'].has_key(type):
            self.__dict__['typestamps'][type]=[]
        self.__dict__['typestamps'][type].append(date)

def addToGraph(graph,date,sender,cc,to):
    if(cc=='to'): cc=False
    else: cc=True

    if(not graph.has_key(sender)):
        graph[sender]=Node(sender,[(date,cc,to)])
    else:
        graph[sender].receivers.append((date,cc,to))

    # count statistics for CC flag
    if(cc):
        graph[sender].tos+=1
    else:
        graph[sender].ccs+=1

    # count statistics for incomming messages
    if(not graph.has_key(to)):
        graph[to]=Node(to)
    if(cc):
        graph[to].inccs+=1
    else:
        graph[to].intos+=1

def stats(graph):
    topTo=[]
    topCc=[]
    topInTo=[]
    topInCc=[]
    for k in graph.keys():
        p=graph[k]
        bisect.insort(topTo,(p.tos,p.name))
        bisect.insort(topCc,(p.ccs,p.name))
        bisect.insort(topInTo,(p.intos,p.name))
        bisect.insort(topInCc,(p.inccs,p.name))

    result=""
    for (stat,name) in [(topTo,"top recepients"),
                        (topCc, "top CC receivers"),
                        (topInTo, "top ???"),
                        (topInCc, "top cc ???")]:
        stat.reverse()
        result+="%s\n" % (name)
        result+=reduce(lambda y,x: y+"%s\t%s\n" % (x[1],x[0]), stat[0:10],"")+"\n"
    return result

def loadPersonMap():
    if(os.path.exists(PERSONMAPFILE)):
        fp=open(PERSONMAPFILE,'r')
        while(fp):
            line=fp.readline()
            if not line:
                break
            (email,name)=line.split(" ",1)
            personmap[email]=name.strip()

def buildGraph():
    graph={}
    q=Role.select()
    for edge in q:
        sender=edge.msg
        if(edge.msg.sender and edge.msg.sender.owner):
            sender=edge.msg.sender.owner.fullname
        elif(edge.msg.sender):
            sender=edge.msg.sender.username+"@"+edge.msg.sender.mailserver
        if(sender and personmap.has_key(sender)):
            sender=personmap[sender]

        receiver=edge.email
        if(edge.email and edge.email.owner):
            receiver=edge.email.owner.fullname
        elif(edge.email):
            receiver=edge.email.username+"@"+edge.email.mailserver
        if(receiver and personmap.has_key(receiver)):
           receiver=personmap[receiver]

        if(CONFIG['format']=="log"):
            print edge.msg.delivered,sender, edge.header.name, receiver

        addToGraph(graph,edge.msg.delivered,sender,edge.header.name, receiver)
    return graph

def graphviz(graph):
    pass

def dumpResults(graph):
    if(CONFIG['format']=="graphviz"):
        print graphviz(graph)
    print stats(graph)

def main():
    loadPersonMap()
    graph=buildGraph()
    dumpResults(graph)

if __name__=='__main__':
   try:
       opts, args = getopt.gnu_getopt(sys.argv[1:],
                                      "hfd:",
                                      ["help",
                                       "format=",
                                       "database="])
   except getopt.GetoptError:
       usage()
       sys.exit(2)
   for o, a in opts:
      if o in ("-h", "--help"):
         usage()
         sys.exit()
      elif o in ("-d", "--database"):
         if(a and os.path.isfile(a)):
            CONFIG['database'] = a
      elif o in ("-f", "--format"):
         if(a and a in ("graphviz","log")):
            CONFIG['format'] = a
         else:
            usage()
            sys.exit()
   psyco.full()
   sys.exit(main())
